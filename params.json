{
  "name": "Concursus",
  "tagline": "An Event-Sourcing Framework for Java 8",
  "body": "# Concursus\r\n\r\n[![Maven Central](https://img.shields.io/maven-central/v/com.opencredo/concourse.svg)](http://search.maven.org/#artifactdetails%7Ccom.opencredo%7Cconcursus%7C0.2%7Cpom)\r\n[![Build Status](https://travis-ci.org/opencredo/concursus.svg?branch=master)](https://travis-ci.org/opencredo/concursus)\r\n\r\n_Concursus_ is a Java 8 framework for building applications that use CQRS and event sourcing patterns, with a Cassandra event log implementation.\r\n\r\n## Getting Started\r\n\r\nCreate a project with dependencies on `concursus-mapping`, `concursus-domain-json` and `jackson-datatype-jsr310`:\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.opencredo</groupId>\r\n    <artifactId>concursus-mapping</artifactId>\r\n</dependency>\r\n\r\n<dependency>\r\n    <groupId>com.opencredo</groupId>\r\n    <artifactId>concursus-domain-json</artifactId>\r\n</dependency>\r\n\r\n<dependency>\r\n    <groupId>com.fasterxml.jackson.datatype</groupId>\r\n    <artifactId>jackson-datatype-jsr310</artifactId>\r\n</dependency>\r\n```\r\n\r\nThe first thing we might want to do is generate some events. To begin with, we need an interface class that defines the events we want to create:\r\n\r\n```java\r\n@HandlesEventsFor(\"person\")\r\npublic interface Events {\r\n    @Initial\r\n    void created(StreamTimestamp ts, UUID personId, String name, LocalDate dateOfBirth);\r\n    void changedName(StreamTimestamp ts, UUID personId, String newName);\r\n    void movedToAddress(StreamTimestamp ts, UUID personId, UUID addressId);\r\n    @Terminal\r\n    void deleted(StreamTimestamp ts, UUID personId);\r\n}\r\n```\r\n\r\nEach method in this interface defines an event which can occur to a person. We generate an event by calling one of these methods, which results in an event being sent to an `EventOutChannel`. Let's create a channel that simply prints the event to the console, and then create a proxy implementation of `PersonEvents` that sends events to this channel:\r\n\r\n```java\r\n// Create an EventOutChannel that simply prints events to the command line\r\nEventOutChannel outChannel = System.out::println;\r\n\r\n// Create a proxy that sends events to the outChannel.\r\nPersonEvents proxy = EventEmittingProxy.proxying(outChannel, PersonEvents.class);\r\n\r\n// Send an event via the proxy.\r\nproxy.created(StreamTimestamp.now(), UUID.randomUUID(), \"Arthur Putey\", LocalDate.parse(\"1968-05-28\"));\r\n```\r\n\r\nThis will output a String like the following:\r\n\r\n```\r\nperson:b2fb2f38-0473-4359-b62b-fad149caf2d5 created_0\r\nat 2016-03-31T10:31:17.981Z/\r\nwith person/created_0{dateOfBirth=1968-05-28, name=Arthur Putey}\r\n```\r\n\r\nThis means that an event of type `created_0` occurred to the object `person:b2fb2f38-0473-4359-b62b-fad149caf2d5` at `2016-03-31T10:31:17.981Z`, and this event had two parameters associated with it, `name` and `dateOfBirth`.\r\n\r\nWe can have the event encoded as JSON if we use an `EventOutChannel` that performs the encoding:\r\n\r\n```java\r\n// Create an EventOutChannel that formats events as JSON and sends them to a command line printer.\r\nEventInChannel<String> print = System.out::println;\r\nObjectMapper objectMapper = new ObjectMapper()\r\n        .findAndRegisterModules()\r\n        .configure(SerializationFeature.INDENT_OUTPUT, true);\r\nEventOutChannel outChannel = JsonEventOutChannel.using(objectMapper, print);\r\n\r\n// Create a proxy that sends events to the outChannel.\r\nPersonEvents proxy = EventEmittingProxy.proxying(outChannel, PersonEvents.class);\r\n\r\n// Send an event via the proxy.\r\nproxy.created(StreamTimestamp.now(), UUID.randomUUID(), \"Arthur Putey\", LocalDate.parse(\"1968-05-28\"));\r\n```\r\n\r\nThis will output JSON like the following:\r\n\r\n```json\r\n{\r\n  \"aggregateType\" : \"person\",\r\n  \"aggregateId\" : \"b449861a-0e8f-4012-bfe9-98a2a4f620f9\",\r\n  \"name\" : \"created\",\r\n  \"version\" : \"0\",\r\n  \"eventTimestamp\" : 1459420919667,\r\n  \"streamId\" : \"\",\r\n  \"processingId\" : \"\",\r\n  \"characteristics\" : 1,\r\n  \"parameters\" : {\r\n    \"dateOfBirth\" : [ 1968, 5, 28 ],\r\n    \"name\" : \"Arthur Putey\"\r\n  }\r\n}\r\n```\r\n\r\nInstead of simply printing things to the console, let's start storing events. We can use an `InMemoryEventStore` to begin with:\r\n\r\n```java\r\n// Create an InMemoryEventStore, and a proxy that sends events to it.\r\nInMemoryEventStore eventStore = InMemoryEventStore.empty();\r\nPersonEvents proxy = EventEmittingProxy.proxying(eventStore.toEventOutChannel(), PersonEvents.class);\r\n\r\n// Send an event via the proxy.\r\nfinal UUID personId = UUID.randomUUID();\r\nproxy.created(StreamTimestamp.now(), personId, \"Arthur Putey\", LocalDate.parse(\"1968-05-28\"));\r\n\r\n// Create an EventTypeMatcher based on the Events interface, and use it to map events back out of the store\r\nEventTypeMatcher typeMatcher = EmitterInterfaceInfo.forInterface(PersonEvents.class).getEventTypeMatcher();\r\n// Retrieve the stored events for the aggregate with id=person/personId, and print them to the console.\r\nEventSource.retrievingWith(eventStore)\r\n        .getEvents(typeMatcher, AggregateId.of(\"person\", personId))\r\n        .forEach(System.out::println);\r\n```\r\n\r\nOnce we have stored events, we can replay them to event handlers, mapping them back into method calls on the `PersonEvents` interface:\r\n\r\n```\r\n// Create a mock handler for person events.\r\nPersonEvents handler = mock(PersonEvents.class);\r\n\r\n// Create an InMemoryEventStore, and a proxy that sends events to it.\r\nInMemoryEventStore eventStore = InMemoryEventStore.empty();\r\nPersonEvents proxy = EventEmittingProxy.proxying(eventStore.toEventOutChannel(), PersonEvents.class);\r\n\r\n// Send an event via the proxy.\r\nUUID personId = UUID.randomUUID();\r\nproxy.created(StreamTimestamp.now(), personId, \"Arthur Putey\", LocalDate.parse(\"1968-05-28\"));\r\n\r\n// Replay the stored events for the person with id=person/personId to the handler instance.\r\nDispatchingEventSource.dispatching(EventSource.retrievingWith(eventStore), PersonEvents.class)\r\n        .replaying(personId)\r\n        .replayAll(handler);\r\n\r\n// Verify that the handler received the event.\r\nverify(handler).created(any(StreamTimestamp.class), any(UUID.class), eq(\"Arthur Putey\"), eq(LocalDate.parse(\"1968-05-28\")));\r\n```\r\n\r\nCheck out the [Examples](https://github.com/opencredo/concursus/tree/master/concursus-examples/src/test/java/com/opencredo/concursus/examples) for more detailed examples, including command processing and state-building.\r\n\r\n## Using Cassandra and Redis\r\n\r\nEventually you will want to store events more permanently. Cassandra and Redis event store implementations are provided in `concursus-cassandra` and `concursus-redis` respectively. You will need to create a suitable keyspace and tables in Cassandra before you can use it:\r\n\r\n```cql\r\nCREATE KEYSPACE IF NOT EXISTS concursus\r\n  WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 2 };\r\n\r\nCREATE TABLE IF NOT EXISTS concursus.Event (\r\n   aggregateType text,\r\n   aggregateId uuid,\r\n   eventTimestamp timestamp,\r\n   streamId text,\r\n   processingId timeuuid,\r\n   name text,\r\n   version text,\r\n   parameters map<text, text>,\r\n   characteristics int,\r\n   PRIMARY KEY((aggregateType, aggregateId), eventTimestamp, streamId)\r\n) WITH CLUSTERING ORDER BY (eventTimestamp DESC);\r\n\r\nCREATE TABLE IF NOT EXISTS concursus.Catalogue (\r\n    aggregateType text,\r\n    bucket int,\r\n    aggregateId uuid,\r\n    PRIMARY KEY ((aggregateType, bucket), aggregateId)\r\n) WITH CLUSTERING ORDER BY (aggregateId DESC);\r\n```\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}